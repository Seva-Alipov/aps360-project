#pragma once
#include <string>
#include <vector>

//
// AI-generated problem bank: 520+ classic C-solvable algorithmic problems.
// Suitable for practice, random selection, UI generation, or testing.
//


inline const std::vector<std::string> problems = {
"1. Given an array of integers nums and an integer target, return true if any two elements sum to target.",
"2. Given an array of integers, return the maximum subarray sum over all contiguous subarrays.",
"3. Given an array of integers, return the length of the longest contiguous subarray with strictly increasing values.",
"4. Given an array of integers and a value k, rotate the array to the right by k steps in place.",
"5. Given an array of integers, move all zeros to the end while maintaining the relative order of nonzero elements.",
"6. Given two sorted arrays of integers, merge them into a single sorted array.",
"7. Given an array of integers, remove duplicates in place and return the new length.",
"8. Given an array of integers, return the index of the first element that is strictly greater than its neighbors; return -1 if none.",
"9. Given a sorted array of integers and a target, return the index of target or the index where it should be inserted.",
"10. Given an array of integers, return the number that appears more than n/2 times, assuming such an element always exists.",
"11. Given an array of integers, return the majority element that appears more than n/3 times, or any if none exists.",
"12. Given an array of integers and an integer k, find the k-th largest element in the array.",
"13. Given an array of integers, return the product of all elements except self for each index.",
"14. Given an array of integers, return the length of the longest subarray with sum equal to a given K.",
"15. Given an array of integers, return the length of the longest subarray with sum less than or equal to K.",
"16. Given an array of integers, return the smallest positive integer that does not appear in the array.",
"17. Given an array of integers, return true if the array contains any duplicates.",
"18. Given an array of integers, return true if the array contains two equal values whose indices differ by at most k.",
"19. Given an array of integers and an integer k, return the maximum sum of any contiguous subarray of length k.",
"20. Given an array of integers, return the length of the longest subarray where the number of even and odd elements is equal.",
"21. Given an array of integers, return the maximum difference nums[j] - nums[i] for j > i.",
"22. Given an array of heights, compute how much water can be trapped after raining between the bars.",
"23. Given an array of stock prices, return the maximum profit with at most one buy and one sell.",
"24. Given an array of stock prices, return the maximum profit with as many transactions as you like (cannot hold multiple shares).",
"25. Given an array of integers, return true if there exists a triplet of indices i < j < k such that nums[i] < nums[j] < nums[k].",
"26. Given an array of integers, return the length of the longest contiguous subarray containing only 1s after flipping at most k zeros.",
"27. Given an array of integers, return the length of the smallest contiguous subarray with sum >= target, or 0 if none.",
"28. Given an array of integers, return the total number of subarrays whose sum equals k.",
"29. Given two arrays representing sparse vectors, return their dot product.",
"30. Given a binary array, return the maximum number of consecutive 1s.",
"31. Given a binary array, return the maximum number of consecutive 1s if you can flip at most one 0.",
"32. Given an array of integers representing daily temperatures, return for each day how many days until a warmer temperature, or 0 if none.",
"33. Given a list of intervals, merge all overlapping intervals and return the resulting list.",
"34. Given a list of intervals and a new interval, insert and merge it into the list.",
"35. Given a sorted array of integers, remove all duplicates such that each element appears at most twice and return the new length.",
"36. Given a sorted array of integers, remove all duplicates such that each element appears at most once and return the new length.",
"37. Given an array of integers and an integer k, return true if the array has a continuous subarray of length at least 2 whose sum is a multiple of k.",
"38. Given two arrays where one is a shuffled version of the other with one extra element, return the extra element.",
"39. Given an array of length n containing numbers from 1 to n with some missing and some repeated, return one repeated and one missing number.",
"40. Given an array of integers, partition it so that all odd numbers come before all even numbers, in place.",
"41. Given a string, return the first non-repeating character's index, or -1 if none exist.",
"42. Given a string, determine if it has all unique characters without using additional data structures beyond fixed-size arrays.",
"43. Given two strings s and t, determine if t is an anagram of s.",
"44. Given two strings s and t, return the minimum number of steps to make t an anagram of s by changing characters in t.",
"45. Given a string, return the length of the longest substring without repeating characters.",
"46. Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.",
"47. Given a string, return true if it can be a palindrome after deleting at most one character.",
"48. Given a string of parentheses, determine if the string is valid using a stack.",
"49. Given a string containing various brackets, determine if they are properly balanced and nested.",
"50. Given a string, compress it using counts of repeated characters and return the compressed string if shorter.",
"51. Given a string, return the longest palindromic substring.",
"52. Given two strings, return the length of their longest common subsequence.",
"53. Given a string, return the length of the longest substring that contains at most two distinct characters.",
"54. Given a string, return the length of the longest substring that contains at most k distinct characters.",
"55. Given a string, count the number of palindromic substrings in the string.",
"56. Given a string s and a pattern p, implement simple wildcard matching with '?' and '*' characters.",
"57. Given a string s and a word, remove all occurrences of the word from s.",
"58. Given a string, reverse the order of words while removing extra spaces.",
"59. Given a string, return the index of the first occurrence of a pattern using naive substring search.",
"60. Given a string containing digits, return all possible valid IP addresses that can be formed.",
"61. Given two binary strings, return their sum as a binary string.",
"62. Given two strings, determine if one is a rotation of the other using only one substring check.",
"63. Given a string representing a 32-bit signed integer, implement safe conversion to integer with overflow handling.",
"64. Given a string, determine if it is a valid number with optional sign, decimal point, and exponent.",
"65. Given a string, remove adjacent duplicate characters repeatedly until no more can be removed.",
"66. Given a linked list, remove all nodes with a given value and return the new head.",
"67. Given a singly linked list, reverse it iteratively.",
"68. Given a singly linked list, reverse it recursively.",
"69. Given a singly linked list, determine if it has a cycle using two pointers.",
"70. Given a singly linked list, return the node where the cycle begins, or null if there is no cycle.",
"71. Given two singly linked lists, determine the node at which they intersect or null if they do not intersect.",
"72. Given a singly linked list, remove the n-th node from the end and return the head.",
"73. Given a singly linked list, return the middle node.",
"74. Given a singly linked list, partition it around value x such that nodes less than x come before nodes greater or equal.",
"75. Given a sorted singly linked list, remove all duplicates so that each value appears only once.",
"76. Given a singly linked list and a position k, rotate the list right by k places.",
"77. Given a singly linked list, check whether it is a palindrome.",
"78. Given two sorted singly linked lists, merge them into a new sorted list.",
"79. Given k sorted singly linked lists, merge them into one sorted list.",
"80. Given a singly linked list and a value, delete the node in the middle given only access to that node.",
"81. Given a singly linked list, reorder it from L0->L1->...->Ln to L0->Ln->L1->Ln-1->... in place.",
"82. Given the head of a linked list, remove all nodes that have duplicate numbers, leaving only distinct numbers.",
"83. Implement a stack using a singly linked list.",
"84. Implement a queue using a singly linked list with head and tail pointers.",
"85. Implement a queue using two stacks with amortized O(1) operations.",
"86. Implement a stack that supports push, pop, top, and retrieving the minimum element in O(1).",
"87. Implement a circular queue using a fixed-size array.",
"88. Implement a stack using a fixed-size array with overflow and underflow checks.",
"89. Implement a hash set of integers using separate chaining.",
"90. Implement a hash map from int to int using separate chaining.",
"91. Given an array of integers, find the length of the longest consecutive elements sequence using a hash set.",
"92. Given an integer n, return the number of 1 bits in its binary representation.",
"93. Given an integer n, determine if it is a power of two using bit operations.",
"94. Given an integer n, determine if it is a power of three without using loops or recursion if possible.",
"95. Given two integers, compute their sum without using the + or - operators.",
"96. Given two integers, compute their division result without using *, /, or % operators.",
"97. Given an integer n, return the Hamming weight (number of set bits).",
"98. Given two integers, return the Hamming distance between their binary representations.",
"99. Given an array where every element appears twice except for one, find that single element using bitwise XOR.",
"100. Given an array where every element appears three times except for one, find that single element.",
"101. Given three integers a, b, c, determine if any two add up exactly to the third.",
"102. Given an integer n, return the nth Fibonacci number using iterative DP.",
"103. Given a staircase of n steps, each time you can climb 1 or 2 steps, return the number of distinct ways to climb.",
"104. Given an integer n, return the number of ways to write n as the sum of 1, 3, and 4 using order-sensitive combinations.",
"105. Given an array of integers, find the length of the longest increasing subsequence using DP.",
"106. Given an array of non-negative integers, where each element is the max jump length, determine if you can reach the last index.",
"107. Given an array of non-negative integers representing jump lengths, return the minimum number of jumps to reach the end.",
"108. Given a grid with non-negative costs, find a path from top-left to bottom-right with minimum path sum using DP.",
"109. Given a matrix with obstacles, count unique paths from top-left to bottom-right using DP.",
"110. Given a matrix of characters and a word, determine if the word exists in the grid by moving horizontally or vertically.",
"111. Given a 2D grid of '1's and '0's, count the number of islands using DFS or BFS.",
"112. Given a 2D grid of '1's and '0's, find the size of the largest island.",
"113. Given a 2D grid of integers heights, return the volume of water trapped in the 2D elevation map.",
"114. Given a binary matrix, find the largest square containing only 1s and return its area.",
"115. Given a grid of costs, find the maximum path sum from top to bottom with allowed moves down-left, down, down-right.",
"116. Given a grid of characters, count the number of connected components of equal characters.",
"117. Given a binary tree, return its preorder traversal iteratively.",
"118. Given a binary tree, return its inorder traversal iteratively.",
"119. Given a binary tree, return its postorder traversal iteratively.",
"120. Given a binary tree, return its level-order traversal as a list of levels.",
"121. Given a binary tree, check whether it is height-balanced.",
"122. Given a binary tree, return its maximum depth using DFS.",
"123. Given a binary tree, return its minimum depth to a leaf.",
"124. Given a binary tree, compute the sum of all node values using recursion.",
"125. Given a binary tree, determine if two trees are structurally identical and have the same node values.",
"126. Given a binary tree, determine if it is symmetric around its center.",
"127. Given a binary tree and a target sum, determine if the tree has a root-to-leaf path with this sum.",
"128. Given a binary tree, return all root-to-leaf paths whose sum equals a target.",
"129. Given a binary tree, flatten it into a linked list in place following the preorder traversal.",
"130. Given a binary search tree, insert a value and return the root.",
"131. Given a binary search tree and a value, search for the node containing that value.",
"132. Given a binary search tree and a value, delete the node with that value and return the new root.",
"133. Given a binary search tree, find the k-th smallest element using inorder traversal.",
"134. Given a BST and two node values, find their lowest common ancestor.",
"135. Given a binary tree, find the lowest common ancestor of two given nodes.",
"136. Given a binary tree, find its diameter (the number of nodes or edges on the longest path between two leaves).",
"137. Given a binary tree, return the maximum path sum between any two nodes.",
"138. Given a binary tree, connect nodes at the same level using next pointers.",
"139. Given a binary tree, serialize it into a string and deserialize the string back into the same tree structure.",
"140. Given an undirected graph represented as adjacency lists, perform depth-first search starting from a given node.",
"141. Given an undirected graph represented as adjacency lists, perform breadth-first search starting from a given node.",
"142. Given a directed graph, detect whether it contains a cycle using DFS recursion stack.",
"143. Given a directed acyclic graph, return a topological ordering of its vertices.",
"144. Given an undirected graph, determine if it is bipartite using BFS or DFS.",
"145. Given a graph with weighted edges, compute the shortest paths from a source using Dijkstra's algorithm with adjacency list and min-heap.",
"146. Given a graph with possibly negative edges but no negative cycles, compute single-source shortest paths with Bellman-Ford.",
"147. Given an adjacency matrix of edge weights, compute all-pairs shortest paths using Floyd-Warshall.",
"148. Given a grid where 0 is water and 1 is land, find the shortest path from top-left to bottom-right using BFS.",
"149. Given an undirected connected graph, find a spanning tree using DFS or BFS.",
"150. Given an undirected weighted graph, find a minimum spanning tree using Prim's algorithm.",
"151. Given an undirected weighted graph, find a minimum spanning tree using Kruskal's algorithm and union-find.",
"152. Implement a disjoint set union (union-find) structure with path compression and union by rank.",
"153. Given an array of integers, count the number of pairs whose absolute difference is at most k using two pointers.",
"154. Given an array of intervals representing meetings, determine the minimum number of meeting rooms required.",
"155. Given an array of points on a 2D plane, find the closest pair of points using O(n^2) brute force.",
"156. Given an array of non-negative integers, arrange them such that they form the largest possible number when concatenated.",
"157. Given an array of integers and a target, find three integers whose sum is closest to target.",
"158. Given an array of integers, return all unique triplets whose sum is zero.",
"159. Given an array of integers, return all unique quadruplets whose sum equals target.",
"160. Given two sorted arrays, find the median of the combined data set in O(log(min(n,m))) time if possible.",
"161. Implement binary search on a sorted array to find the index of a target or -1 if not found.",
"162. Given a rotated sorted array with distinct elements, find the index of the minimum element.",
"163. Given a rotated sorted array, search for a target value and return its index or -1.",
"164. Given a 2D matrix where each row and column is sorted, search for a target value efficiently.",
"165. Implement an LRU (Least Recently Used) cache with given capacity supporting get and put in O(1) average time.",
"166. Implement a simple memory pool for fixed-size blocks using an array and a free list.",
"167. Given an array of tasks (characters) and a cooldown n, return the least number of time units to finish all tasks with idle allowed.",
"168. Given an array of integer ratings of children, distribute candies such that each child with higher rating gets more candies than neighbors, minimizing total.",
"169. Given an array of integers, return the maximum product of a contiguous subarray.",
"170. Given a 2D board with 'X' and 'O', capture all regions surrounded by 'X' using DFS or BFS.",
"171. Given a 2D board of letters and a list of words, return all words that exist in the board.",
"172. Given a set of non-overlapping intervals and a new interval, insert the interval and keep the set non-overlapping.",
"173. Given an array of heights representing histogram bars, compute the area of the largest rectangle in the histogram.",
"174. Given a circular array of integers, find the maximum subarray sum in circular fashion.",
"175. Given an array of integers, return the number of inversions (pairs i<j with nums[i]>nums[j]) using modified merge sort.",
"176. Given a sorted array and a target, return the first and last position of target in the array.",
"177. Given an integer, return the number of trailing zeros in factorial of that integer.",
"178. Given n non-negative integers representing vertical lines, find two lines that together with x-axis form a container holding the most water.",
"179. Given a list of non-negative integers, determine if you can partition it into two subsets with equal sum.",
"180. Given an array of coin denominations and an amount, compute the minimum number of coins to make that amount or -1.",
"181. Given an array of coin denominations and an amount, compute the total number of ways to make that amount.",
"182. Given a matrix of characters, find the longest path such that all characters on the path are distinct.",
"183. Given a matrix of integers, find the length of the longest increasing path using DFS and memoization.",
"184. Given a 2D matrix, implement an immutable prefix sum structure that answers submatrix sum queries in O(1).",
"185. Given a stream of integers, implement a data structure that supports inserting and finding the current median.",
"186. Given a stream of integers, implement a structure that returns the first unique integer at any time.",
"187. Given an array of intervals, remove the minimum number of intervals so that the rest of the intervals are non-overlapping.",
"188. Given an array where each element is 0, 1, or 2, sort the array in-place using a single pass partitioning algorithm.",
"189. Given a 2D matrix, rotate it 90 degrees clockwise in place.",
"190. Given an array of integers, sort it using quicksort implemented in C style.",
"191. Given a linked list, sort it in O(n log n) time using merge sort.",
"192. Implement mergesort on an array of integers using recursion.",
"193. Implement heapsort on an array of integers using a binary heap stored in an array.",
"194. Implement a binary max-heap with push and pop operations using an array.",
"195. Given an array of integers and an integer k, find the k most frequent elements.",
"196. Given a list of words, group them into lists of anagrams.",
"197. Given a list of words, return the longest common prefix among them.",
"198. Given a matrix of integers, print the elements in spiral order.",
"199. Given an integer n, generate all valid combinations of n pairs of parentheses using backtracking.",
"200. Given a set of distinct integers, generate all possible subsets using backtracking.",
"201. Given a set of distinct integers, generate all possible permutations using backtracking.",
"202. Given a multiset of integers with possible duplicates, generate all unique permutations.",
"203. Given a candidate set of numbers and a target, find all unique combinations where the chosen numbers sum to target; each number may be chosen multiple times.",
"204. Given a candidate set of numbers and a target, find all unique combinations where each number is used at most once and sums to target.",
"205. Given a string of digits, return all possible letter combinations it could represent on a phone keypad.",
"206. Given a string, partition it into all possible lists of substrings where each substring is a palindrome.",
"207. Given a chessboard position for a knight, compute the minimum number of moves to reach a target square using BFS.",
"208. Given coordinates of points, cluster points such that any two points in the same cluster are at distance less than or equal to d using DFS.",
"209. Given an integer grid representing rooms and walls, fill each empty room with the distance to its nearest gate using BFS.",
"210. Given a 2D binary grid, find the shortest path from top-left to bottom-right with 8-direction moves if cells are 0.",
"211. Given an array of integers, return the maximum sum of any strictly increasing subsequence.",
"212. Given an array, return the number of strictly increasing contiguous subarrays.",
"213. Given an array of integers, return the longest mountain (increasing then decreasing) subarray length.",
"214. Given a binary array, return the minimum number of flips to make the array alternating.",
"215. Given a binary array, return the minimum number of flips to make it monotone non-decreasing.",
"216. Given an array of integers, return the longest alternating even-odd subarray.",
"217. Given an array of integers, return the longest alternating positive-negative subarray.",
"218. Given an array of integers, return true if the array is a valid mountain array.",
"219. Given an array of integers, return the number of arithmetic subarrays of length >= 3.",
"220. Given an array, count subarrays with all unique elements.",
"221. Given an array, count subarrays where the maximum element appears at least twice.",
"222. Given an array, find the longest subarray where every element occurs at most twice.",
"223. Given an array of integers, find the longest subarray with absolute difference ≤ limit.",
"224. Given an array of integers, return the length of the longest subarray whose elements differ by exactly 1.",
"225. Given two integer arrays, compute their intersection with multiplicity.",
"226. Given two integer arrays, compute their union with multiplicity.",
"227. Given a sorted array, remove all occurrences of a given value in place.",
"228. Given an array, return the length of the longest prefix where prefix sum never becomes negative.",
"229. Given an array of integers, find the minimal number of increments to make it strictly increasing.",
"230. Given an array of integers, determine if it can be made strictly increasing with at most one removal.",
"231. Given an array of integers, find the longest contiguous subarray that is already sorted.",
"232. Given an array, return the number of index pairs (i,j) with i<j and nums[i] divisible by nums[j].",
"233. Given an array, return the number of index pairs where nums[i] XOR nums[j] is even.",
"234. Given an array, return the number of pairs with XOR less than k.",
"235. Given an array, return the smallest distance between any two equal elements.",
"236. Given an array, return the largest distance between any two equal elements.",
"237. Given an array, find the minimum number of subarrays needed such that each subarray has strictly increasing values.",
"238. Given an array, split it into minimum number of chunks that can be individually sorted to produce sorted arr.",
"239. Given a sorted array, return the number of unique elements.",
"240. Given a sorted array, return the number of distinct absolute values.",
"241. Given an array, return the number of contiguous subarrays where min and max differ by at most 2.",
"242. Given an array, return the length of the longest prefix with strictly increasing cumulative maximum.",
"243. Given an array, return the length of the longest prefix with strictly decreasing cumulative minimum.",
"244. Given a binary array, return the maximum number of 1s by flipping exactly one contiguous segment.",
"245. Given a binary array, return the minimum number of bit flips required to convert it to all 1s.",
"246. Given a binary array, return the minimum number of segments of consecutive equal bits.",
"247. Given an array, return true if the array contains an increasing quadruple.",
"248. Given an array, return true if the array contains a 132 pattern.",
"249. Given an array, sort by number of set bits (Hamming weight).",
"250. Given an array of integers, return a stable sort by absolute value.",
"251. Given a linked list, delete every second node.",
"252. Given a linked list, move all even-valued nodes after odd-valued nodes.",
"253. Given a linked list, check if the values are strictly increasing.",
"254. Given a linked list, return the length of its longest strictly increasing run.",
"255. Given a linked list, remove alternating nodes starting from the second.",
"256. Given a linked list, split into two lists: nodes at even indices and nodes at odd indices.",
"257. Given two linked lists, weave them together one node at a time.",
"258. Given a linked list, detect if two nodes are swapped and correct them.",
"259. Given a linked list, count nodes with prime values.",
"260. Given a linked list, remove all nodes that have greater value nodes to their right.",
"261. Given a linked list, reverse nodes in groups of size k (iterative).",
"262. Given a linked list, rotate left by k nodes.",
"263. Given a linked list, move last node to front.",
"264. Given a linked list, move front node to end.",
"265. Given a linked list, delete nodes with odd values.",
"266. Given a linked list, delete nodes with even values.",
"267. Implement a doubly linked list with push/pop at both ends.",
"268. Implement a stack with O(1) getMax().",
"269. Implement a stack with O(1) getAverage(), using sum tracking.",
"270. Implement a queue with O(1) getMin().",
"271. Implement a priority queue using a sorted array.",
"272. Implement a deque using a circular array.",
"273. Implement a frequency stack (pop most frequent element).",
"274. Implement a monotonic increasing stack.",
"275. Implement a monotonic decreasing stack.",
"276. Implement a stack that can reverse its internal array representation.",
"277. Implement a queue that supports removing arbitrary values.",
"278. Implement a simple Bloom filter with bit array.",
"279. Implement a bitset supporting set, clear, flip, count.",
"280. Implement a rolling hash for strings.",
"281. Implement Rabin–Karp substring search.",
"282. Implement KMP substring search.",
"283. Implement naive pattern matching for multiple patterns.",
"284. Given a string, return the number of substrings with exactly k distinct characters.",
"285. Given a string, return the number of substrings with at most k distinct characters.",
"286. Given a string, return the number of vowels in every sliding window of size k.",
"287. Given a string, return true if any permutation of pattern appears as a substring.",
"288. Given a string, return all start indices where an anagram of pattern appears.",
"289. Given a string, return smallest substring containing all characters of another string.",
"290. Given a string, return all palindromic partitions (list of lists).",
"291. Given a string, convert to zigzag form with given numRows (classic).",
"292. Given a string, perform run-length decoding.",
"293. Given a string, remove all occurrences of k consecutive identical characters.",
"294. Given a string, check if it is made of repeated substring patterns.",
"295. Given a string, find the minimum window that contains every vowel at least once.",
"296. Given a string, return the longest substring with strictly increasing lexicographic order.",
"297. Given a string, return the longest substring with strictly decreasing lexicographic order.",
"298. Given a string, return true if it can be segmented into space-separated dictionary words.",
"299. Given a string, return the minimum cuts needed for palindrome partitioning.",
"300. Given a string, return the lexicographically smallest rotation.",
"301. Given a string, compute Z-function values.",
"302. Given a string, compute prefix-function (pi array).",
"303. Given a string, test if rotation by k makes it a palindrome.",
"304. Given a string, remove all characters that appear more than twice.",
"305. Given a string, remove all characters that appear exactly once.",
"306. Given a string, return the maximum distance between two equal characters.",
"307. Given a string, return number of substrings whose characters sum (ASCII) to target.",
"308. Given two strings, return number of matching character pairs (same index, same char).",
"309. Given a string, reverse characters at prime indices.",
"310. Given a string, reverse characters at even indices.",
"311. Given a string, remove characters at Fibonacci indices.",
"312. Given a string, compute frequency of every pair of consecutive characters.",
"313. Given a word, compute all unique permutations whose first character is a vowel.",
"314. Given a string, generate all subsequences.",
"315. Given a string, generate all subsequences of length k.",
"316. Given a string, generate all subsequences with alternating vowels/consonants.",
"317. Given a binary string, return longest substring with equal 0s and 1s.",
"318. Given a binary string, return longest balanced substring (equal 01 and 10 transitions).",
"319. Given a binary string, count substrings that start and end with same bit.",
"320. Given a binary string, count substrings where ones are grouped.",
"321. Given a matrix, count local maxima.",
"322. Given a matrix, count local minima.",
"323. Given a matrix, compute prefix maximum matrix.",
"324. Given a matrix, compute prefix minimum matrix.",
"325. Given a matrix, rotate 180 degrees.",
"326. Given a matrix, rotate 270 degrees.",
"327. Given a matrix, reflect horizontally.",
"328. Given a matrix, reflect vertically.",
"329. Given a matrix, reflect on main diagonal.",
"330. Given a matrix, reflect on anti-diagonal.",
"331. Given a matrix, count number of increasing paths starting at each cell.",
"332. Given a matrix, find all connected components of equal parity (even/odd).",
"333. Given a matrix, color each connected component with a unique ID.",
"334. Given a matrix, compute number of islands of size >= k.",
"335. Given a matrix, compute number of lakes (0-regions surrounded by 1s).",
"336. Given a matrix, fill every region of zeros completely surrounded by ones.",
"337. Given a matrix, compute the chessboard distance transform.",
"338. Given a matrix, compute the Manhattan distance transform.",
"339. Given a matrix, find nearest 1 for every cell.",
"340. Given a matrix, find nearest 0 for every cell.",
"341. Given a matrix, count number of diagonally connected components.",
"342. Given a matrix, flood-fill with BFS using 8-direction connectivity.",
"343. Given a grid, find minimum steps to collect all keys and open all doors.",
"344. Given a grid, find minimum steps to move from start to end avoiding circular obstacles.",
"345. Given a grid, simulate Conway's Game of Life by one step.",
"346. Given a grid, simulate Game of Life until stable.",
"347. Given a grid, count number of edges around farmland patches.",
"348. Implement BFS-level-order traversal for general graphs stored in adjacency matrix.",
"349. Implement DFS traversal for graphs stored in adjacency matrix.",
"350. Given a directed graph, find all nodes reachable from source.",
"351. Given a directed graph, find all nodes that can reach the target.",
"352. Given a directed graph, find nodes that are part of any cycle.",
"353. Given a directed graph, count simple cycles of length 3.",
"354. Given a directed graph, find strongly connected components (Kosaraju).",
"355. Given a directed graph, find strongly connected components (Tarjan).",
"356. Given an undirected graph, count connected components.",
"357. Given an undirected graph, find all bridges.",
"358. Given an undirected graph, find all articulation points.",
"359. Given a graph, find shortest cycle length.",
"360. Given a graph, detect odd cycle.",
"361. Given a graph, determine if graph is a tree.",
"362. Given a graph, find all leaf nodes.",
"363. Given weighted graph, find second-shortest path.",
"364. Given weighted graph, find all nodes on any shortest path from s to t.",
"365. Given weighted graph, find minimum cycle basis (simplified for small graphs).",
"366. Given weighted DAG, find longest path.",
"367. Given tree, compute subtree sizes.",
"368. Given tree, compute subtree sums.",
"369. Given tree, find diameter in O(n).",
"370. Given tree, find all nodes at distance k from root.",
"371. Given tree, compute lowest common ancestor using binary lifting.",
"372. Given tree, compute Euler tour representation.",
"373. Given tree, check if it's strictly binary (every node 0 or 2 children).",
"374. Given tree, check if it is complete.",
"375. Given tree, check if it is full.",
"376. Given tree, check if it is perfect.",
"377. Given binary tree, compute sum of deepest leaves.",
"378. Given binary tree, compute average value of each level.",
"379. Given binary tree, count number of leaves.",
"380. Given binary tree, count number of full nodes.",
"381. Given binary tree, count number of nodes with exactly one child.",
"382. Given binary tree, count nodes where left subtree height equals right subtree height.",
"383. Given binary tree, compute width of each level.",
"384. Given binary tree, find longest path where node values strictly increase.",
"385. Given binary tree, find longest path where node values strictly decrease.",
"386. Given BST, check if valid with no recursion.",
"387. Given BST, find predecessor of a given key.",
"388. Given BST, find successor of a given key.",
"389. Given BST, find closest value to target.",
"390. Given BST, count nodes within [L,R].",
"391. Given BST, trim tree so all values lie in interval [L, R].",
"392. Given BST, find kth largest element.",
"393. Given N-ary tree, perform level-order traversal.",
"394. Given N-ary tree, count nodes at each depth.",
"395. Given N-ary tree, compute height.",
"396. Given N-ary tree, find diameter.",
"397. Given N-ary tree, serialize and deserialize.",
"398. Implement union-find supporting rollback.",
"399. Implement union-find supporting time-travel queries.",
"400. Implement union-find that tracks size of each component.",
"401. Implement union-find that tracks max element in each component.",
"402. Implement union-find that supports undo of last k operations.",
"403. Implement bitwise trie (0/1 trie) for integers.",
"404. Given array of integers, build bitwise trie for fast XOR queries.",
"405. Given an array, answer queries of maximum XOR with given value.",
"406. Given integers a,b,m, compute (a*b) mod m without overflow.",
"407. Implement fast exponentiation (binary exponentiation).",
"408. Implement modular exponentiation.",
"409. Implement modular inverse using extended Euclid.",
"410. Implement GCD and LCM.",
"411. Implement sieve of Eratosthenes.",
"412. Given n, return list of primes ≤ n.",
"413. Given n, check if prime using trial division.",
"414. Given integer, factorize into primes.",
"415. Given two integers, compute gcd of all pairs in array.",
"416. Given array, compute prefix gcd.",
"417. Given array, compute suffix gcd.",
"418. Given integer array, find longest subarray whose gcd is >1.",
"419. Given integer array, find longest subarray whose gcd equals 1.",
"420. Given integer n, compute sum of divisors.",
"421. Given integer n, list all divisors.",
"422. Given integer array, count pairs whose gcd is 1.",
"423. Given points in 2D, find number of collinear triples.",
"424. Given points in 2D, find number of collinear pairs.",
"425. Given points in 2D, find closest pair using divide & conquer.",
"426. Given points in 2D, compute convex hull (Graham scan).",
"427. Given points in 2D, compute perimeter of convex hull.",
"428. Given polygon, compute its area using Shoelace formula.",
"429. Given polygon, determine if point lies inside (ray casting).",
"430. Given two line segments, check if they intersect.",
"431. Given circle and point, check if inside.",
"432. Given rectangle and point, check if inside.",
"433. Given set of points, find maximum Manhattan distance.",
"434. Given set of points, find maximum Euclidean distance.",
"435. Given 2D grid, compute largest rectangle of 1s.",
"436. Given histogram matrix, compute largest rectangle in binary matrix.",
"437. Implement BFS to find shortest knight path on arbitrary grid.",
"438. Implement BFS on weighted edges with weights {0,1}.",
"439. Implement BFS for 8-direction movement.",
"440. Implement multi-source BFS.",
"441. Implement DFS iterative using manual stack.",
"442. Implement Bellman-Ford detecting negative cycle.",
"443. Implement SPFA (shortest path faster algorithm).",
"444. Implement topological sort using BFS (Kahn).",
"445. Implement adjacency list to adjacency matrix conversion.",
"446. Implement adjacency matrix to adjacency list conversion.",
"447. Implement Floyd–Warshall with path reconstruction.",
"448. Given weighted graph, detect arbitrage (negative log sum cycle).",
"449. Implement simple TCP congestion window simulator.",
"450. Implement round-robin scheduler simulation.",
"451. Implement LRU using arrays instead of linked list.",
"452. Implement LFU cache.",
"453. Implement randomized set supporting insert/delete/getRandom.",
"454. Implement reservoir sampling for stream of integers.",
"455. Implement weighted reservoir sampling.",
"456. Implement skip list (basic insertion/find).",
"457. Implement binary search tree without recursion.",
"458. Implement arena allocator (bump allocator).",
"459. Implement stack allocator.",
"460. Implement slab allocator for fixed-size chunks.",
"461. Implement custom calloc using malloc.",
"462. Implement memory alignment function that returns aligned pointer.",
"463. Implement simple CRC32 checksum.",
"464. Implement FNV-1a hash for strings.",
"465. Implement DJB2 hash for strings.",
"466. Implement rolling polynomial hash.",
"467. Implement base64 encode.",
"468. Implement base64 decode.",
"469. Implement hex encode/decode.",
"470. Implement URL encoding/decoding.",
"471. Implement SHA-1 simplified (non-cryptographic).",
"472. Implement MD5 simplified (non-cryptographic).",
"473. Implement Hamming code encode/decode.",
"474. Implement Reed–Solomon simplified over small GF.",
"475. Implement binary search tree to sorted array conversion.",
"476. Implement sorted array to balanced BST conversion.",
"477. Implement threaded binary tree inorder traversal.",
"478. Implement offline RMQ using Sparse Table.",
"479. Implement LCA using Euler tour + RMQ.",
"480. Implement doubling technique for RMQ.",
"481. Implement Fenwick tree (BIT) for prefix sums.",
"482. Implement Fenwick tree for prefix minimums.",
"483. Implement Fenwick tree for prefix maximums.",
"484. Implement segment tree for range sum.",
"485. Implement segment tree for range min.",
"486. Implement segment tree for range max.",
"487. Implement segment tree with lazy propagation.",
"488. Implement segment tree that supports range XOR.",
"489. Implement segment tree for range gcd.",
"490. Implement segment tree for range assignment.",
"491. Implement prefix sum structure supporting point update.",
"492. Implement difference array with range updates.",
"493. Implement immutable range-sum queries via prefix sum.",
"494. Implement wavelet tree (simple subset of operations).",
"495. Implement binary lifting for ancestor queries.",
"496. Implement trie for lowercase words.",
"497. Implement compressed trie.",
"498. Implement suffix array using doubling.",
"499. Implement LCP array (Kasai).",
"500. Implement suffix automaton (minimal, simplified).",
"501. Implement dictionary with BK-tree (for edit distance <= k).",
"502. Implement Levenshtein distance DP for two strings.",
"503. Implement Damerau–Levenshtein distance.",
"504. Implement edit distance with limited operations.",
"505. Implement knapsack with 0/1 item selection.",
"506. Implement knapsack unbounded.",
"507. Implement knapsack for exact-fill.",
"508. Implement DP for longest bitonic subsequence.",
"509. Implement DP for number of binary strings of length n with no consecutive zeroes.",
"510. Implement DP for number of ways to tile 2×n board with dominoes.",
"511. Implement DP for number of ways to tile n×m board with 1×2 and 2×1 dominoes (small constraints).",
"512. Implement DP to count ways to climb stairs with steps {1,2,3}.",
"513. Implement DP for maximal sum path in triangle.",
"514. Implement DP for minimal sum path in triangle.",
"515. Implement DP for counting subsets whose sum is divisible by m.",
"516. Implement DP for longest divisible subset.",
"517. Implement DP to count ways to reach sum S using given dice.",
"518. Implement DP to compute minimum number of operations to convert one integer array into another.",
"519. Implement DP to count number of palindromic subsequences.",
"520. Implement DP for optimal coin-picking from row of coins with turns."
};


